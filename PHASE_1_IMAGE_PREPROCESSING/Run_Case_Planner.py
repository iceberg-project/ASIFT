# -*- coding: utf-8 -*-
"""
Created on Thu Feb 07 15:51:33 2019

Run_Case_Planner.py -- Takes two sets of tiles (generated by ./Tile_Planner.py) and sets up image pairs to process, saves the output.
Provides options for only selecting certain subsets of tiles to run against each other.

@author: mmacferrin
"""
#import os
import numpy
import argparse

#######################################################################################
## Code for importing the parent directory in order to get the File_Locations object
import os,sys,inspect
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
parentdir = os.path.dirname(currentdir)
#sys.path.insert(0,parentdir)
## Also add the utility folder for the csv names
utilitydir = os.path.join(parentdir, "UTILITIES")
sys.path.insert(0,utilitydir)
#######################################################################################
import CSV_auto_reader
import CSV_writer

def generate_run_case_CSVs(source_csv, 
                           target_csv, 
                           output_csv = None,
                           row_filter="all",
                           source_pyramid_levels=None, 
                           target_pyramid_levels=None, 
                           verbose=True):
            
    # Read both csv files, get a numpy array from each.
    source_csv_data = CSV_auto_reader.read_simple_csv(source_csv, verbose=verbose)
    target_csv_data = CSV_auto_reader.read_simple_csv(target_csv, verbose=verbose)
    
    # Output fields data type, just appending "source_" and "target_" to the field already in each CSV and keeping data-types the same
    output_dtype = numpy.dtype( [("source_" + name, source_csv_data[0][name].dtype) for name in source_csv_data.dtype.names] + \
                                [("target_" + name, target_csv_data[0][name].dtype) for name in target_csv_data.dtype.names] )

    # Make the filter string lower-case
    if type(row_filter) is str:
        row_filter = row_filter.strip().lower()

    if row_filter is None or row_filter=='all':
        output_rows = _select_row_pairs_ALL(source_csv_data,
                                            target_csv_data,
                                            output_dtype)

    elif row_filter=='pyramid_levels':
        output_rows = _select_row_pairs_filtered_by_pyramid_levels(source_csv_data,
                                                                   target_csv_data,
                                                                   source_pyramid_levels,
                                                                   target_pyramid_levels,
                                                                   output_dtype)
        
    else:
        raise ValueError("Unknown row filter in Run_Case_Planner.py: '{0}'".format(row_filter))

    # Write out the file.
    if output_csv is not None:
        CSV_writer.write_csv(output_rows, output_csv, verbose=verbose)
    
    return output_rows


def _select_row_pairs_ALL(source_rows, target_rows, output_dtype):
    '''Take ALL the rows of source and pair them with ALL the rows of target.'''
    output_array = numpy.empty((len(source_rows) * len(target_rows),), dtype=output_dtype)

    row_N = len(target_rows)    
    # The field names of both these shoudl be identical
    assert source_rows.dtype.names == target_rows.dtype.names

    for i,srow in enumerate(source_rows):
        for j,trow in enumerate(target_rows):
            output_i = i*row_N + j
            for name in srow.dtype.names:
                output_array[output_i]["source_" + name] = srow[name]
                output_array[output_i]["target_" + name] = trow[name]
                
    return output_array
            

def _select_row_pairs_filtered_by_pyramid_levels(source_rows, target_rows, source_pyramid_levels, target_pyramid_levels, output_dtype):
    '''Take only selected pyramid-levels from source, and run them against selected pyramid levels of target.'''
    # Process lists of pyramid levels, for the source image, into actual lists.
    # If it's a string, convert it to a list.
    if type(source_pyramid_levels) == str:
        source_str = source_pyramid_levels.strip()
        if len(source_str) == 0:
            source_pyramid_levels = None
        else:
            source_pyramid_levels = [int(d) for d in source_str.split(',')]
    # Do the same, process list for the target image
    if type(target_pyramid_levels) == str:
        target_str = target_pyramid_levels.strip()
        if len(target_str) == 0:
            target_pyramid_levels = None
        else:
            target_pyramid_levels = [int(d) for d in target_str.split(',')]

    # Filter out the source and target pyramid levels
    if source_pyramid_levels != None:
        source_rows = numpy.array([row for row in source_rows if row["pyramid_level"] in source_pyramid_levels], dtype=source_rows.dtype)
    if target_pyramid_levels != None:
        target_rows = numpy.array([row for row in target_rows if row["pyramid_level"] in target_pyramid_levels], dtype=target_rows.dtype)

    # Once the rows have been filtered out, it's the same as pairing them all.
    return _select_row_pairs_ALL(source_rows, target_rows, output_dtype)
            
            

def define_and_parse_arguments():
    # TODO: Update for this file.
    parser = argparse.ArgumentParser(description = "Take two image tile CSV files generated by 'Tile_Planner.py', and select individual tiles to run against each other.")
    parser.add_argument('source_csv',  type=str, help="Filename for the 'Tiles_[].csv' file of the source image.")
    parser.add_argument('target_csv',  type=str, help="Filename for the 'Tiles_[].csv' file of the target image.")
    parser.add_argument('output_csv',  type=str, help="Filename for the CSV file for tile pairs to be run by the ASIFT Executable.")
    parser.add_argument('-filter', type=str, default='all', required=False, help="Filter to use. Options: \"all\", \"pyramid_levels\" (default: all)")
    parser.add_argument('-source_pyramid_levels', type=str, default='', required=False, help="If -filter pyramid_levels is used: Comma-separated list of pyramid levels to use from the source image. Example: 2,4,8,16 or \"2, 4, 8, 16\". Default to using them all.")
    parser.add_argument('-target_pyramid_levels', type=str, default='', required=False, help="If -filter pyramid_levels is used: Comma-separated list of pyramid levels to use from the target image. Example: 2,4,8,16 or \"2, 4, 8, 16\". Default to using them all.")
    parser.add_argument('--verbose', required=False, action='store_true', default=False, help="Increase the output verbosity")

    return parser.parse_args()

if __name__ == "__main__":
    args = define_and_parse_arguments()
    # Given two images, create CSV files that desribe the tiles in each image,
    # as well as the matchings between both sets of image tiles to run ASIFT upon.

    row_filter = args.filter.strip().lower()
    if row_filter not in ["", "all", "pyramid_levels"]:
        print "Uknown filter option: " + args.filter
        args.print_help()
    elif row_filter == "":
        row_filter = "all"

    else:
        generate_run_case_CSVs(args.source_csv,
                               args.target_csv,
                               args.output_csv,
                               row_filter=row_filter,
                               source_pyramid_levels=args.source_pyramid_levels,
                               target_pyramid_levels=args.target_pyramid_levels,
                               verbose = args.verbose
                               )
